Secure Development in Go
A quick guide on how to build APIs securely with Go
5 Feb 2018

Dion Bramley
Senior Software Engineer, Spalk
dionbramley@gmail.com
github.com/dionb

* Why build go?

Designed to fix Google sized problems in software engineering:

- slow builds
- each programmer using a different subset of the language
- poor program understanding (code hard to read, poorly documented, and so on)
- duplication of effort
- cost of updates
- difficulty of writing automatic tools
- cross-language builds

* What is Go?

- compiled
- statically typed
- designed for concurrency
- garbage-collected
- simple syntax
- no magic - every operation is O(1)
- consistent look


* Hello World

.play helloWorld.go

* fizzbuzz

.play fizzbuzz.go /START/,/STOP/


* Language features

* Deep pass by value

.play passByValue.go /START/,/STOP/
.play passByPointer.go /START/,/STOP/

* Multiple and named returns

.code namedReturn.go

* Exceptions are not exceptional

.code error.go

* Defer

.code defer.go /START/,


* No generics - waaaaaat??

* Jon Skeet on generics:

Bad:

- Type information is lost at compile time, so not available at execution time
- Can't be used for value types 
- Syntax for calling generic methods sucks (IMO)
- Syntax for constraints can get confusing
- Wildcarding is generally confusing
- Various restrictions due to the above - casting etc

Good:

- Wildcarding allows covariance/contravariance to be specified at calling side
- It's better than nothing!

* Implicit interface satisfaction

.code interface.go /START1/,/STOP1/

* Interfaces part 2

.play interface.go /STOP1/,/STOP2/

* Easy, lightweight multithreading
 go list.Sort()  // run list.Sort concurrently; don't wait for it.

Distribute tasks to multiple threads:

 func Announce(messages []string, destination string) {
 	for _,m := range messages {
     	go func(m string) {
     		buf := bytes.NewBufferString(m)
     		resp, _ := http.Post(destination, "", &buf)
    	}(m)  // Note the parentheses - must call the function.
  	}
 }
* Share memory by communicating

.play channel.go /START/,/^}/

* Sync with select

.play select.go /START/,/STOP/



* Escape analysis

Anytime a value is shared outside the scope of a function’s stack frame, it will be placed (or allocated) on the heap. It’s the job of the escape analysis algorithms to find these situations and maintain a level of integrity in the program. The integrity is in making sure that access to any value is always accurate, consistent and efficient. - Ardan labs


* Build your own API

* A simple GET

.play simpleGET.go

* DB CRUD with JSON

* OS.Exec

* Crypto/bcrypt

* Testing

* Tooling

* Why NOT Go?

- No implementations of insecure protocols
- It isn't something you already know
- Binaries, binaries and more binaries
- Can't distribute libraries securely - no DLLs
- Plugins?
- Using it is slow. I need to move fast a break things